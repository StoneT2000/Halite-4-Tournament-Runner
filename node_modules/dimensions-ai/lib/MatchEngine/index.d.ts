import { DeepPartial } from "../utils/DeepPartial";
import { Design } from '../Design';
import { Logger } from '../Logger';
import { Agent } from '../Agent';
import { Match } from '../Match';
/** @ignore */
declare type EngineOptions = MatchEngine.EngineOptions;
/**
 * The Match Engine that takes a {@link Design} and its specified {@link EngineOptions} to form the backend
 * for running matches with agents.
 */
export declare class MatchEngine {
    /** The design the engine runs on */
    private design;
    /** Engine options */
    private engineOptions;
    /** Override options */
    private overrideOptions;
    /** Logger */
    private log;
    /**
     * A coordination signal to ensure that all processes are indeed killed due to asynchronous initialization of agents
     * There is a race condition when a tournament/match is being destroyed and while every match is being destroyed, some
     * matches are in the initialization stage where they call the engine's initialize function. As a result, when we
     * send a match destroy signal, we spawn some processes and haven't spawned some others for the agents. As a result,
     * all processes eventually get spawned but not all are cleaned up and killed.
     */
    private killOffSignal;
    /** approx extra buffer time given to agents due to engine processing for timeout mechanism */
    static timeoutBuffer: number;
    /**
     * Match engine constructor
     * @param design - the design to use
     * @param loggingLevel - the logging level for this engine
     */
    constructor(design: Design, loggingLevel: Logger.LEVEL);
    /** Set log level */
    setLogLevel(loggingLevel: Logger.LEVEL): void;
    /** Get the engine options */
    getEngineOptions(): MatchEngine.EngineOptions;
    /** Set the engine options */
    setEngineOptions(newOptions?: DeepPartial<EngineOptions>): void;
    /**
     * Starts up the engine by intializing processes for all the agents and setting some variables for a match
     * @param agents - The agents involved to be setup for the given match
     * @param match - The match to initialize
     * @returns a promise that resolves once succesfully initialized
     */
    initialize(agents: Array<Agent>, match: Match): Promise<void>;
    /**
     * Returns a promise that resolves once the process succesfully spawned and rejects if error occurs
     * @param pid - process id to check
     */
    private spawnedPromise;
    /**
     * Initializes a single agent, called by {@link initialize}
     * @param agent - agent to initialize
     * @param match - match to initialize in
     */
    private initializeAgent;
    /**
     * Handles partial stdout from an agent
     * @param agent - the agent to process the command for
     * @param str - the string the agent sent
     */
    private handleCommmand;
    /**
     * Attempts to gracefully and synchronously stop a match's agents
     * @param match - the match to stop
     */
    stop(match: Match): Promise<void>;
    /**
     * Attempts to gracefully and synchronously resume a previously stopped match
     * @param match - the match to resume
     */
    resume(match: Match): Promise<void>;
    /**
     * Kills all agents and processes from a match and cleans up. Kills any game processes as well. Shouldn't be used
     * for custom design based matches. Called by {@link Match}
     *
     * @param match - the match to kill all agents in and clean up
     */
    killAndClean(match: Match): Promise<void>;
    /**
     * Kills an agent and closes the process, and no longer attempts to receive coommands from it anymore
     * @param agent - the agent to kill off
     */
    kill(agent: Agent): Promise<void>;
    /**
     * Returns a promise that resolves with all the commands loaded from the previous time step of the provided match
     * This coordinates all the Agents and waits for each one to finish their step
     * @param match - The match to get commands from agents for
     * @returns a promise that resolves with an array of {@link MatchEngine.Command} elements, holding the command and id
     * of the agent that sent it
     */
    getCommands(match: Match): Promise<Array<MatchEngine.Command>>;
    /**
     * Sends a message to a particular process governed by an agent in a specified match specified by the agentID
     * @param match - the match to work with
     * @param message - the message to send to agent's stdin
     * @param agentID - id that specifies the agent in the match to send the message to
     */
    send(match: Match, message: string, agentID: Agent.ID): Promise<boolean>;
    /**
     * TODO: Initialize a custom design based match and run through some basic security measures
     * @param match - The match to initialize with a custom design
     */
    initializeCustom(match: Match): Promise<boolean>;
    /**
     * Run a custom match. A custom match much print to stdout all relevant data to be used by the engine and
     * Dimensions framework. All output after the conclude command from {@link Design.OverrideOptions} is outputted
     * is stored as a list of new line delimited strings and returned as the match results. The match must exit with
     * exit code 0 to be marked as succesfully complete and the processing of results stops and this function resolves
     * @param match - the match to run
     */
    runCustom(match: Match): Promise<Array<string>>;
    /**
     * Attempts to stop a {@link Match} based on a custom {@link Design}
     * @param match - the match to stop
     */
    stopCustom(match: Match): Promise<void>;
    /**
     * Attempts to resume a {@link Match} based on a custom {@link Design}
     * @param match - the match to resume
     */
    resumeCustom(match: Match): Promise<void>;
    /**
     * Attempts to kill and clean up anything else for a custom design based match
     * @param match - the match to kill and clean up
     */
    killAndCleanCustom(match: Match): Promise<void>;
    /**
     * Parses a list of arguments for a given match and populates relevant strings as needed
     * @param match - the match to parse arguments for
     * @param args - the arguments to parse
     */
    private parseCustomArguments;
}
export declare module MatchEngine {
    /**
     * Various policies available that describe the requirements before an agent is marked as done with sending commands
     * at some time step
     */
    enum COMMAND_FINISH_POLICIES {
        /**
         * Agent's finish their commands by sending a finish symbol, namely {@link EngineOptions.commandFinishSymbol}
         */
        FINISH_SYMBOL = "finish_symbol",
        /**
         * Agent's finish their commands by either sending a finish symmbol or after they send
         * {@link EngineOptions.commandLines.max} lines
         */
        LINE_COUNT = "line_count",
        /**
         * Custom finishing policy provided by user. Not allowed at the moment
         */
        CUSTOM = "custom"
    }
    /**
     * Engine Options that specify how the {@link MatchEngine} should operate on a {@link Match}
     */
    interface EngineOptions {
        /** The command streaming type */
        commandStreamType: MatchEngine.COMMAND_STREAM_TYPE;
        /**
         * Delimiter for seperating commands from agents in their stdout and then sending these delimited commands to
         * {@link Design.update}. If an agent sent `move a b 3,run 24 d,t 3` and the delimiter is `','` then the
         * {@link Design.update} function will receive commands `'move a b 3'` and `'run 24 d'` and `'t 3'`
         * @default ','
         */
        commandDelimiter: string;
        /**
         * The finish symbol to use
         * @default 'D_FINISH'
         */
        commandFinishSymbol: string;
        /**
         * Which kind of command finishing policy to use
         * @default 'finish_symbol'
         */
        commandFinishPolicy: MatchEngine.COMMAND_FINISH_POLICIES;
        /**
         * Options for the {@link COMMAND_FINISH_POLICIES.LINE_COUNT} finishing policy. Used only if this policy is active
         */
        commandLines: {
            /**
             * Maximum lines of commands delimited by new line characters '\n' allowed before engine cuts off an Agent
             * @default 1
             */
            max: number;
            /**
             * Whether the engine should wait for a newline character before processing the line of commands received
             * This should for most cases be set to `true`; false will lead to some unpredictable behavior.
             * @default true
             */
            waitForNewline: boolean;
        };
        /**
         * Whether agents output to standard error is logged by the matchengine or not
         *
         * It's suggested to let agent output go to a file.
         *
         * @default true
         */
        noStdErr: boolean;
        /**
         * Options for timeouts of agents
         */
        timeout: {
            /**
             * On or not
             * @default true
             */
            active: boolean;
            /**
             * How long in milliseconds each agent is given before they are timed out and the timeoutCallback
             * function is called
             * @default 1000
             */
            max: number;
            /**
             * the callback called when an agent times out.
             * Default is kill the agent with {@link Match.kill}.
             */
            timeoutCallback: 
            /**
             * @param agent the agent that timed out
             * @param match - the match the agent timed out in
             * @param engineOptions - a copy of the engineOptions used that timed out the agent
             */
            (agent: Agent, match: Match, engineOptions: EngineOptions) => void;
        };
        /**
         * Options related to the memory usage of agents. The memoryCallback is called when the limit is reached
         */
        memory: {
            /**
             * Whether or not the engine will monitor the memory use
             * @default true
             */
            active: boolean;
            /**
             * Maximum number of bytes an agent can use before the memoryCallback is called
             * @default 1 GB (1,000,000,000 bytes)
             */
            limit: number;
            /**
             * The callback called when an agent raeches the memory limit
             * Default is kill the agent with {@link Match.kill}
             */
            memoryCallback: 
            /**
             * @param agent the agent that reached the memory limit
             * @param match - the match the agent was in
             * @param engineOptions - a copy of the engineOptions used in the match
             */
            (agent: Agent, match: Match, engineOptions: EngineOptions) => void;
            /**
             * How frequently the engine checks the memory usage of an agent in milliseconds
             * @default 100
             */
            checkRate: number;
            /**
             * Whether or not to use `ps` instead of `procfile` for measuring memory through the
             * pidusage package.
             *
             * @default true
             */
            usePs: boolean;
        };
    }
    /** Standard ways for commands from agents to be streamed to the MatchEngine for the {@link Design} to handle */
    enum COMMAND_STREAM_TYPE {
        /** First come first serve for commands run. Not implemented */
        PARALLEL = "parallel",
        /** Each agent's set of commands is run before the next agent */
        SEQUENTIAL = "sequential"
    }
    /**
     * A command delimited by the delimiter of the match engine from all commands sent by agent specified by agentID
     */
    interface Command {
        /**
         * The string command received
         */
        command: string;
        /**
         * The id of the agent that sent this command
         */
        agentID: Agent.ID;
    }
    enum AGENT_EVENTS {
        /**
         * Event emitted by process of {@link Agent} when memory limit is exceeded
         */
        EXCEED_MEMORY_LIMIT = "exceedMemoryLimit",
        /**
         * Event emitted by process of {@link Agent} when it times out.
         */
        TIMEOUT = "timeout"
    }
    /**
     * Dynammic Data strings are strings in the {@link OverrideOptions} arguments array that are automatically replaced
     * with dynamic data as defined in the documentation of these enums
     */
    enum DynamicDataStrings {
        /**
         * `D_FILES` is automatically populated by a space seperated string list of the file paths provided for each of the
         * agents competing in a match.
         *
         * NOTE, these paths don't actually need to be files, they can be directories or anything that works with
         * your own command and design
         *
         * @example Suppose the paths to the sources the agents operate on are `path1`, `path2`, `path3`. Then `D_FILES`
         * will be passed into your command as `path1 path2 path3`
         */
        D_FILES = "D_FILES",
        /**
         * `D_AGENT_IDS` is automatically populated by a space seperated string list of the agent IDs of every agent being
         * loaded into a match in the same order as D_FILES. This should always be sorted by default as agents are loaded
         * in order from agent ID `0` to agent ID `n-1`in a `n` agent match
         *
         * @example Suppose a match is running with agents with IDs `0, 1, 2, 3`. Then `D_AGENT_IDS` will be passed into
         * your command as `0 1 2 3`
         */
        D_AGENT_IDS = "D_AGENT_IDS",
        /**
         * `D_TOURNAMENT_IDS` is automatically populated by a space seperated string list of the tournament ID numbers of
         * the agents being loaded into the match in the same order. If no tournament is being run all the ID numbers will
         * default to 0 but still be passed in to the command you give for the override configurations
         *
         * @example Suppose a match in a tournament is running 2 agents with tournament IDs `Qb6NyTxufGGU`, `EGg3tSN2KUgl`
         * Then `D_TOURNAMENT_IDS` will be passed into your command as `Qb6NyTxufGGU EGg3tSN2KUgl`
         */
        D_TOURNAMENT_IDS = "D_TOURNAMENT_IDS",
        /**
         * D_MATCH_ID is automatically replaced with the id of the match being run
         *
         * @example Suppose the match has ID `eF1uEacgfgMm`, then `D_MATCH_ID` is passed into your command as `eF1uEacgfgMm`
         */
        D_MATCH_ID = "D_MATCH_ID",
        /**
         * D_MATCH_NAME is automatically replaced with the name of the match being run
         *
         * @example Suppose the match has name 'my_match'. Then `D_MATCH_NAME` is passed into your commnad as `my_match`
         */
        D_MATCH_NAME = "D_MATCH_NAME",
        /**
         * D_NAMES is automatically replaced with the names of the agents
         *
         * @example Suppose the agents 0 and 1 had names `bob, richard`. Then `D_NAMES` is passed into your commnad as
         * `bob richard`
         */
        D_NAMES = "D_NAMES"
    }
}
/** name of the bot user that owns the agent's process */
export declare const BOT_USER = "dimensions_bot";
/** @ignore */
export declare const ROOT_USER = "root";
export {};
