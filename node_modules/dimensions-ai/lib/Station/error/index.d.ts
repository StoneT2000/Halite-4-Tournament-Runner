/**
 * This file defines error classes based on their semantic meaning. It abstracts away
 * HTTP status codes so they can be used in a RESTful way without worrying about a
 * consistent error interface.
 *
 * These classes descend from the base Error class, so they also automatically capture
 * stack traces--useful for debugging.
 */
import express from 'express';
import { Logger } from '../../Logger';
/**
 * Base error class.
 *
 * Supports HTTP status codes and a custom message.
 * From the ACM Membership Portal Backend repository
 */
export declare class HttpError extends Error {
    status: any;
    constructor(name: any, status: any, message?: any);
}
export declare class UserError extends HttpError {
    constructor(message: string | Error);
}
export declare class BadRequest extends HttpError {
    constructor(message: string | Error);
}
export declare class Unauthorized extends HttpError {
    constructor(message: string | Error);
}
export declare class Forbidden extends HttpError {
    constructor(message: string | Error);
}
export declare class NotFound extends HttpError {
    constructor(message: string | Error);
}
export declare class Unprocessable extends HttpError {
    constructor(message: string | Error);
}
export declare class InternalServerError extends HttpError {
    constructor(message: string | Error);
}
export declare class NotImplemented extends HttpError {
    constructor(message: string | Error);
}
/**
 * General error handling middleware. Attaches to Express so that throwing or calling next() with
 * an error ends up here and all errors are handled uniformly.
 */
export declare const errorHandler: (log: Logger) => (err: HttpError, req: express.Request<import("express-serve-static-core").ParamsDictionary>, res: express.Response<any>, next: express.NextFunction) => void;
