"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = __importDefault(require("mongoose"));
var DeepMerge_1 = require("../../../utils/DeepMerge");
var DeepCopy_1 = require("../../../utils/DeepCopy");
var Schema = mongoose_1.default.Schema;
var ObjectId = mongoose_1.default.Schema.Types.ObjectId;
var defaultMatchSchemaOptions = {
    state: false,
    results: true,
    creationDate: true,
    finishDate: true,
    agents: true
};
var MatchSchemaCreator = function (options) {
    if (options === void 0) { options = {}; }
    var schemaOptions = DeepMerge_1.deepMerge(DeepCopy_1.deepCopy(defaultMatchSchemaOptions), options);
    var schema = new Schema({
        name: String,
        id: { type: String, index: true, unique: true, required: true },
        governID: String,
        replayFile: { type: String, required: false },
        replayFileKey: { type: String, required: false }
    });
    // TODO: This can be more streamlined. Perhaps in the MatchSchemaCreator we also store the kind of type they should be
    if (schemaOptions.creationDate) {
        schema.add({
            creationDate: { type: Schema.Types.Date }
        });
    }
    if (schemaOptions.finishDate) {
        schema.add({
            finishDate: { type: Schema.Types.Date }
        });
    }
    if (schemaOptions.results) {
        schema.add({
            results: Schema.Types.Mixed
        });
    }
    if (schemaOptions.state) {
        schema.add({
            state: Schema.Types.Mixed
        });
    }
    if (schemaOptions.agents) {
        schema.add({
            agents: Schema.Types.Mixed
        });
    }
    return schema;
};
exports.default = MatchSchemaCreator;
//# sourceMappingURL=match.js.map