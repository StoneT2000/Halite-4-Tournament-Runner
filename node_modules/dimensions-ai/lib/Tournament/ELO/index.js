"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DimensionError_1 = require("../../DimensionError");
var ELOSystem = /** @class */ (function () {
    function ELOSystem(kfactor, startingScore) {
        this.kfactor = kfactor;
        this.startingScore = startingScore;
    }
    ELOSystem.prototype.createRating = function (startingScore) {
        if (startingScore === void 0) { startingScore = this.startingScore; }
        return new ELORating(startingScore);
    };
    ELOSystem.prototype.expectedScores1v1 = function (p1, p2) {
        var Q_1 = Math.pow(10, p1.score / 400);
        var Q_2 = Math.pow(10, p2.score / 400);
        var E_1 = Q_1 / (Q_1 + Q_2); // expected for player 1
        var E_2 = Q_2 / (Q_1 + Q_2); // expected for player 2
        return [E_1, E_2];
    };
    ELOSystem.prototype.rate1v1 = function (p1, p2, scores) {
        var _a = this.expectedScores1v1(p1, p2), E_1 = _a[0], E_2 = _a[1];
        // actual should be two length array with the scores of each player
        p1.score = Math.round(p1.score + this.kfactor * (scores[0] - E_1));
        p2.score = Math.round(p2.score + this.kfactor * (scores[1] - E_1));
    };
    ELOSystem.prototype.rate = function (ratings, ranks) {
        if (ranks.length != ratings.length)
            throw new DimensionError_1.FatalError('Ratings and ranks lengths do not match!');
        var expectedMatrix = []; // element at i, j is expected score of player i against j.
        var scoreDeltas = new Array(ratings.length); // stores the change in scores
        var actualScores = []; // store the actual scores against all other players based on ranks argument
        for (var i = 0; i < ratings.length; i++) {
            expectedMatrix.push(new Array(ratings.length));
            actualScores.push(0);
        }
        // calculate total scores as well against all players
        for (var i = 0; i < ratings.length; i++) {
            for (var j = i + 1; j < ratings.length; j++) {
                var _a = this.expectedScores1v1(ratings[i], ratings[j]), E_i = _a[0], E_j = _a[1];
                expectedMatrix[i][j] = E_i;
                expectedMatrix[j][i] = E_j;
            }
        }
        for (var i = 0; i < ratings.length; i++) {
            var E_i_total = 0;
            for (var j = 0; j < ratings.length; j++) {
                if (j != i) {
                    // store expected total scores for player i
                    E_i_total += expectedMatrix[i][j];
                    // store actual total scores for player i
                    if (ranks[i] > ranks[j]) {
                        actualScores[i] += 1;
                    }
                    else if (ranks[i] == ranks[j]) {
                        actualScores[i] += 0.5;
                    }
                }
            }
            // update player scores
            ratings[i].score = Math.round(ratings[i].score + this.kfactor * (E_i_total - actualScores[i]));
        }
    };
    return ELOSystem;
}());
exports.ELOSystem = ELOSystem;
var ELORating = /** @class */ (function () {
    function ELORating(score) {
        this.score = score;
    }
    return ELORating;
}());
exports.ELORating = ELORating;
//# sourceMappingURL=index.js.map