import { Tournament, Player } from "..";
import { DeepPartial } from "../../utils/DeepPartial";
import { Design } from "../../Design";
import { Dimension, NanoID } from "../../Dimension";
import EliminationState = Elimination.State;
import EliminationConfigs = Elimination.Configs;
/**
 * The Elimination Tournament Class. Runs a single-elimination tournament.
 *
 * Meant for single instance use only
 */
export declare class Elimination extends Tournament {
    configs: Tournament.TournamentConfigs<EliminationConfigs>;
    state: EliminationState;
    matchHashes: Array<string>;
    private shouldStop;
    private resumePromise;
    private resumeResolver;
    private resolveStopPromise;
    constructor(design: Design, files: Array<string> | Array<{
        file: string;
        name: string;
    }>, tournamentConfigs: Tournament.TournamentConfigsBase, id: NanoID, dimension: Dimension);
    /**
     * Get the current tournament configs
     */
    getConfigs(): Tournament.TournamentConfigs<EliminationConfigs>;
    /**
     * Set configs to use. Merges the provided configurations and overwrites provided fields with what is provided
     * @param configs - new tournament configs to update with
     */
    setConfigs(configs?: DeepPartial<Tournament.TournamentConfigs<EliminationConfigs>>): void;
    /**
     * Gets the rankings of the tournament. This will return the tournament rankings in the elimination tournament
     */
    getRankings(): {
        player: Player;
        wins: number;
        losses: number;
        matchesPlayed: number;
        seed: number;
        rank: number;
    }[];
    /**
     * Stops the tournament if it's running
     */
    stop(): Promise<void>;
    /**
     * Reesumes the tournament if it's stopped
     */
    resume(): Promise<void>;
    /**
     * Runs the tournament to completion. Resolves with {@link Elimination.State} once the tournament is finished
     * @param configs - tournament configurations to use
     */
    run(configs?: DeepPartial<Tournament.TournamentConfigs<EliminationConfigs>>): Promise<Tournament.Elimination.State>;
    /**
     * Handles a match and updates stats appropriately
     * @param matchInfo - The match to run
     */
    private handleMatch;
    private initialize;
    private generateFirstRounds;
    private generateRound;
    /**
     * Performs a Fisher Yates Shuffle
     * @param arr - the array to shuffle
     */
    private shuffle;
    internalAddPlayer(player: Player): void;
    updatePlayer(player: Player, oldname: string, oldfile: string): Promise<void>;
}
/**
 * The Elimination Tournament namespace
 */
export declare namespace Elimination {
    /**
     * Configuration interface for {@link EliminationTournament}
     */
    interface Configs extends Tournament.TournamentTypeConfig {
        /**
         * Number of times the elimination tournament runs
         * @default `2`
         */
        times: number;
        /**
         * Number of times a player can lose before being eliminated. Can be 1 for single elimination. 2 for double
         * elimination is not implemented yet
         * @default `1`
         */
        lives: 1;
        /**
         * The seeding of the competitors in the order they are loaded.
         * When set to null, no seeds are used. When the ith array element is null, the ith competitor loaded, which has * tournament ID of i, does not have a seed.
         * @default `null`
         */
        seeding: Array<number>;
    }
    /**
     * The {@link EliminationTournament} state, consisting of the current player statistics and past results
     */
    interface State extends Tournament.TournamentTypeState {
        /**
         * A map from a {@link Player} Tournament ID string to statistics
         */
        playerStats: Map<string, {
            player: Player;
            wins: number;
            losses: number;
            matchesPlayed: number;
            seed: number;
            rank: number;
        }>;
        /**
         * Stats for this Tournament in this instance. Intended to be constant memory usage
         */
        statistics: {
            totalMatches: number;
        };
        currentRound: number;
        /**
         * A match hash in the tournament indicating what seeds are meant to compete against each other.
         * This maps a match hash to the result at the part of the tournament, indicating who won and lost
         */
        resultsMap: Map<string, {
            winner: Player;
            loser: Player;
        }>;
    }
}
